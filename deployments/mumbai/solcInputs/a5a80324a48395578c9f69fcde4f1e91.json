{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/BookingService.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract BookingService {\n    struct Booking {\n        address user;\n        uint256 serviceId;\n        uint256 bookingTime;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 price;\n        bool confirmed;\n        bool paid;\n        bool paymentReleased;\n    }\n\n    uint256 public serviceCount;\n    uint256 public bookingCount;\n    uint256 public schoolCount;\n    mapping(uint256 => Booking) public bookings;\n    mapping(uint256 => address) public schools;\n    address public owner;\n\n    event ServiceCreated(uint256 serviceId, address serviceProvider, string serviceName, uint256 price, string departureLocation, string destination, uint256 availableSeats, uint256 departureTime);\n    event ServiceCanceled(uint256 serviceId);\n    event BookingCreated(uint256 bookingId, address user, uint256 serviceId, uint256 bookingTime, uint256 startTime, uint256 endTime, uint256 price);\n    event BookingConfirmed(uint256 bookingId);\n    event BookingPaid(uint256 bookingId);\n\n    constructor() {\n        serviceCount = 0;\n        bookingCount = 0;\n        schoolCount = 0;\n        owner = msg.sender;\n    }\n\n    struct Service {\n        uint256 serviceId;\n        address serviceProvider;\n        string serviceName;\n        uint256 price;\n        string departureLocation;\n        string destination;\n        uint256 availableSeats;\n        uint256 departureTime;\n        bool isActive;\n        bool isFinished;\n        bool isValidated;\n        bool isPaid;\n    }\n\n    mapping(uint256 => Service) public services;\n\n    function createService(string memory _serviceName, uint256 _price, string memory _departureLocation, string memory _destination, uint256 _availableSeats, uint256 _departureTime) public {\n        serviceCount++;\n        require(_availableSeats > 0, \"Number of available seats must be greater than 0\");\n        require(_departureTime > block.timestamp, \"Invalid departure time\");\n        require(_price >= 0, \"Price cannot be negative\");\n        Service storage newCarpool = services[serviceCount];\n        newCarpool.serviceProvider = msg.sender;\n        newCarpool.departureLocation = _departureLocation;\n        newCarpool.destination = _destination;\n        newCarpool.availableSeats = _availableSeats;\n        newCarpool.departureTime = _departureTime;\n        newCarpool.price = _price;\n        newCarpool.isActive = true;\n        newCarpool.isFinished = false;\n        newCarpool.isValidated = false;\n        newCarpool.isPaid = false;\n        newCarpool.serviceName = \"carpool\";\n        newCarpool.serviceId = serviceCount;\n\n        emit ServiceCreated(serviceCount, msg.sender, _serviceName, _price,_departureLocation, _destination, _availableSeats, _departureTime);\n    }\n\n    function cancelService(uint256 _serviceId) public {\n        require(_serviceId <= serviceCount, \"Invalid service ID\");\n        require(services[_serviceId].serviceProvider == msg.sender, \"You are not the service provider\");\n        require(services[_serviceId].isActive, \"Service is already canceled\");\n\n        services[_serviceId].isActive = false;\n\n        emit ServiceCanceled(_serviceId);\n    }\n\n    function finishService(uint256 _serviceId) public {\n        require(_serviceId <= serviceCount, \"Invalid service ID\");\n        require(services[_serviceId].serviceProvider == msg.sender, \"You are not the service provider\");\n        require(services[_serviceId].isActive, \"Service is not active\");\n\n        services[_serviceId].isActive = false;\n        services[_serviceId].isFinished = true;\n\n        emit ServiceCanceled(_serviceId);\n    }\n\n    function isSchoolRegistered(address _schoolAddress) public view returns (bool) {\n    for (uint256 i = 1; i <= schoolCount; i++) {\n        if (schools[i] == _schoolAddress) {\n            return true; // Sender's address is found in the mapping\n        }\n    }\n    return false; // Sender's address is not found in the mapping\n}\n\n    function validateService(uint256 _serviceId) public {\n        require(_serviceId <= serviceCount, \"Invalid service ID\");\n        require(isSchoolRegistered(msg.sender), \"School not registered\");\n        require(services[_serviceId].isFinished, \"Service not yet finished\");\n\n        services[_serviceId].isValidated = true;\n    }\n\n    function bookService(uint256 _serviceId, uint256 _startTime, uint256 _endTime, uint256 _price) public {\n        require(_serviceId > 0 && _serviceId <= serviceCount, \"Invalid service ID\");\n        require(_startTime > block.timestamp, \"Invalid start time\");\n        require(_endTime > _startTime, \"Invalid end time\");\n        require(_price >= 0, \"Price cannot be negative\");\n\n        bookingCount++;\n        Booking storage newBooking = bookings[bookingCount];\n        newBooking.user = msg.sender;\n        newBooking.serviceId = _serviceId;\n        newBooking.bookingTime = block.timestamp;\n        newBooking.startTime = _startTime;\n        newBooking.endTime = _endTime;\n        newBooking.price = _price;\n        newBooking.confirmed = false;\n        newBooking.paid = false;\n        newBooking.paymentReleased = false;\n\n        emit BookingCreated(bookingCount, msg.sender, _serviceId, block.timestamp, _startTime, _endTime, _price);\n    }\n\n    function confirmBooking(uint256 _bookingId) public {\n        require(_bookingId <= bookingCount, \"Invalid booking ID\");\n        require(services[bookings[_bookingId].serviceId].serviceProvider == msg.sender, \"You are not the service provider\");\n        require(!bookings[_bookingId].confirmed, \"Booking already confirmed\");\n\n        bookings[_bookingId].confirmed = true;\n\n        emit BookingConfirmed(_bookingId);\n    }\n\n    function markBookingAsPaid(uint256 _bookingId) public {\n        require(_bookingId <= bookingCount, \"Invalid booking ID\");\n        require(bookings[_bookingId].user == msg.sender, \"You are not the user\");\n        require(bookings[_bookingId].confirmed, \"Booking is not confirmed\");\n        require(!bookings[_bookingId].paid, \"Payment has already been made\");\n\n        bookings[_bookingId].paid = true;\n\n        emit BookingPaid(_bookingId);\n    }\n\n    function getBooking(uint256 _bookingId) public view returns (\nBooking memory\n) {\n    require(_bookingId <= bookingCount, \"Invalid booking ID\");\n\n    Booking storage booking = bookings[_bookingId];\n\n    return (\nbooking\n    );\n}\n\n        function getService(uint256 _serviceId) public view returns (\nService memory\n) {\n    require(_serviceId <= serviceCount, \"Invalid booking ID\");\n\n    Service storage service = services[_serviceId];\n\n    return (\nservice\n    );\n}\n\n    function addSchool(address _schoolAddress) public {\n        require(owner == msg.sender, \"only owner can call this function\");\n        schoolCount++;\n        schools[schoolCount] = _schoolAddress;\n    }\n\n}\n\n"
    },
    "contracts/PaymentSystem.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./BookingService.sol\";  // Replace with the correct path to the BookingService contract\n\n\ncontract PaymentSystem {\n    address public owner;\n    IERC20 public maticToken;\n    BookingService public bookingService;\n\n    event PaymentLocked(uint256 bookingId, address payer, uint256 amount);\n    event PaymentReleased(uint256 bookingId, address payer, uint256 amount);\n\n    constructor(address _maticTokenAddress, address _bookingServiceAddress) {\n        owner = msg.sender;\n        maticToken = IERC20(_maticTokenAddress);\n        bookingService = BookingService(_bookingServiceAddress);\n    }\n\n    function lockPayment(uint256 _bookingId) public {\n        require(bookingService.getBooking(_bookingId).user == msg.sender, \"You are not the booking user\");\n        require(bookingService.getBooking(_bookingId).confirmed, \"Booking is not confirmed\");\n        require(!bookingService.getBooking(_bookingId).paid, \"Payment has already been made\");\n\n        uint256 amount = bookingService.getBooking(_bookingId).price;\n        require(maticToken.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n\n        bookingService.markBookingAsPaid(_bookingId);\n        emit PaymentLocked(_bookingId, msg.sender, amount);\n    }\n\n    function finishPayment(uint256 _bookingId) public {\n        require(bookingService.getBooking(_bookingId).user == msg.sender, \"You are not the booking user\");\n        require(bookingService.getBooking(_bookingId).confirmed, \"Booking is not confirmed\");\n        require(bookingService.getBooking(_bookingId).paid, \"Payment has not been locked\");\n        require(!bookingService.getBooking(_bookingId).paymentReleased, \"Payment already released\");\n\n        uint256 amount = bookingService.getBooking(_bookingId).price;\n        require(maticToken.transferFrom(address(this), bookingService.getService(bookingService.getBooking(_bookingId).serviceId).serviceProvider, amount), \"Transfer failed\");\n\n        bookingService.markBookingAsPaid(_bookingId);\n        emit PaymentReleased(_bookingId, msg.sender, amount);\n    }\n\n    function withdrawFunds(uint256 _amount) public {\n        require(msg.sender == owner, \"Only the owner can withdraw\");\n        require(_amount <= maticToken.balanceOf(address(this)), \"Insufficient balance\");\n        require(maticToken.transfer(owner, _amount), \"Transfer failed\");\n    }\n\n    function getBalance() public view returns (uint256) {\n        return maticToken.balanceOf(address(this));\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}